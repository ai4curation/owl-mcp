{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OWL Server","text":"<p>OWL Server is a Model-Context-Protocol (MCP) server for working with Web Ontology Language (OWL) ontologies. It provides standardized tools for interacting with OWL ontologies through the MCP protocol, enabling seamless integration with AI assistants and applications.</p>"},{"location":"#what-is-the-model-context-protocol-mcp","title":"What is the Model Context Protocol (MCP)?","text":"<p>The Model Context Protocol (MCP) is an open standard for connecting AI assistants to external tools and data sources. MCP provides a standardized way to expose functionality to large language models (LLMs) like Claude, GPT, and other AI systems.</p> <p>Think of MCP as a \"USB-C port for AI applications\" - it provides a consistent interface that allows AI assistants to:</p> <ul> <li>Access external data (like OWL ontologies)</li> <li>Execute specific operations (like adding/removing axioms)</li> <li>Work with your data in a secure, controlled manner</li> </ul> <p>By implementing the MCP protocol, OWL Server allows AI assistants to directly manipulate ontologies without needing custom integrations for each LLM platform.</p>"},{"location":"#what-is-owl","title":"What is OWL?","text":"<p>The Web Ontology Language (OWL) is a semantic markup language for publishing and sharing ontologies on the web. OWL is designed to represent rich and complex knowledge about things, groups of things, and relations between things.</p> <p>Key OWL concepts that OWL Server helps you manage:</p> <ul> <li>Axioms: Statements that define relationships between entities</li> <li>Classes: Sets or collections of individuals with similar properties</li> <li>Properties: Relationships between individuals or between individuals and data values</li> <li>Individuals: Objects in the domain being described</li> </ul> <p>OWL Server simplifies working with these concepts by providing tools that work with axiom strings in OWL Functional Syntax, avoiding the need to understand complex object models.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>MCP Server Integration: Connect AI assistants directly to OWL ontologies using the standardized Model-Context-Protocol</li> <li>Thread-safe operations: All ontology operations are thread-safe, making it suitable for multi-user environments</li> <li>File synchronization: Changes to the ontology file on disk are automatically detected and synchronized</li> <li>Event-based notifications: Register observers to be notified of changes to the ontology</li> <li>Simple string-based API: Work with OWL axioms as strings in functional syntax without dealing with complex object models</li> </ul>"},{"location":"#mcp-server-quick-start","title":"MCP Server Quick Start","text":"<p>Run the OWL Server as an MCP server directly from the command line:</p> <pre><code># Run the MCP server with stdio transport\n uvx run owl-mcp\n</code></pre> <p>Or integrate within your application:</p> <pre><code>from mcp import StdioServerParameters\nfrom mcp.client.stdio import stdio_client\nfrom mcp import ClientSession\n\n# Start the OWL MCP server\nserver_params = StdioServerParameters(\n    command=\"python\",\n    args=[\"-m\", \"owl_mcp.mcp_tools\"]\n)\n\n# Connect an MCP client\nasync with stdio_client(server_params) as (read, write):\n    async with ClientSession(read, write) as session:\n        await session.initialize()\n\n        # Use MCP tools to work with OWL ontologies\n        result = await session.invoke_tool(\n            \"add_axiom\", \n            {\"owl_file_path\": \"/path/to/ontology.owl\", \n             \"axiom_str\": \"SubClassOf(:Dog :Animal)\"}\n        )\n        print(result)\n\n        # Find axioms matching a pattern\n        axioms = await session.invoke_tool(\n            \"find_axioms\",\n            {\"owl_file_path\": \"/path/to/ontology.owl\",\n             \"pattern\": \"Dog\"}\n        )\n        print(axioms)\n</code></pre>"},{"location":"#available-mcp-tools","title":"Available MCP Tools","text":"<p>OWL Server exposes the following MCP tools:</p> <ul> <li><code>add_axiom</code>: Add an axiom to the ontology</li> <li><code>remove_axiom</code>: Remove an axiom from the ontology</li> <li><code>find_axioms</code>: Find axioms matching a pattern</li> <li><code>get_all_axioms</code>: Get all axioms in the ontology</li> <li><code>add_prefix</code>: Add a prefix mapping to the ontology</li> <li><code>list_active_owl_files</code>: List all OWL files currently being managed</li> </ul>"},{"location":"#core-api-example","title":"Core API Example","text":"<p>The server is built on a core API that can also be used directly:</p> <pre><code>from owl_mcp.owl_api import SimpleOwlAPI\n\n# Initialize the API\napi = SimpleOwlAPI(\"my-ontology.owl\")\n\n# Add a prefix\napi.add_prefix(\"ex:\", \"http://example.org/\")\n\n# Add an axiom\napi.add_axiom(\"ClassAssertion(ex:Person ex:John)\")\n\n# Find axioms\naxioms = api.find_axioms(\":John\")\nfor axiom in axioms:\n    print(axiom)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install owl-server\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>I want t# Getting Started</p> <p>This guide will help you get started with OWL Server. We'll walk through the basic setup and common operations.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install OWL Server using pip:</p> <pre><code>pip install owl-server\n</code></pre> <p>For development purposes, you can install directly from the repository:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#initializing-the-api","title":"Initializing the API","text":"<pre><code>from owl_mcp.owl_api import SimpleOwlAPI\n\n# Initialize with an existing file\napi = SimpleOwlAPI(\"path/to/ontology.owl\")\n\n# Or create a new ontology file\napi = SimpleOwlAPI(\"new-ontology.owl\", create_if_not_exists=True)\n</code></pre>"},{"location":"getting-started/#working-with-prefixes","title":"Working with Prefixes","text":"<pre><code># Add standard prefixes\napi.add_prefix(\"owl\", \"http://www.w3.org/2002/07/owl#\")\napi.add_prefix(\"rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\")\napi.add_prefix(\"rdfs\", \"http://www.w3.org/2000/01/rdf-schema#\")\napi.add_prefix(\"xsd\", \"http://www.w3.org/2001/XMLSchema#\")\n\n# Add a custom prefix\napi.add_prefix(\"ex\", \"http://example.org/\")\n</code></pre>"},{"location":"getting-started/#adding-and-removing-axioms","title":"Adding and Removing Axioms","text":"<pre><code># Add an axiom in OWL functional syntax\napi.add_axiom(\"ClassAssertion(ex:Person ex:John)\")\napi.add_axiom(\"SubClassOf(ex:Student ex:Person)\")\napi.add_axiom(\"ObjectPropertyAssertion(ex:knows ex:John ex:Jane)\")\n\n# Remove an axiom\napi.remove_axiom(\"ClassAssertion(ex:Person ex:John)\")\n</code></pre>"},{"location":"getting-started/#finding-axioms","title":"Finding Axioms","text":"<pre><code># Find all axioms containing a string\naxioms = api.find_axioms(\"ex:Person\")\n\n# Find axioms of a specific type\nclass_axioms = api.find_axioms(pattern=None, axiom_type=\"ClassAssertion\")\n\n# Find axioms of a specific type with a pattern\njohn_class_axioms = api.find_axioms(\"ex:John\", \"ClassAssertion\")\n</code></pre>"},{"location":"getting-started/#observing-changes","title":"Observing Changes","text":"<pre><code># Define a change handler\ndef on_change(event_type, **kwargs):\n    print(f\"Event: {event_type}\")\n    if event_type == \"axiom_added\":\n        print(f\"Added axiom: {kwargs['axiom_str']}\")\n    elif event_type == \"axiom_removed\":\n        print(f\"Removed axiom: {kwargs['axiom_str']}\")\n    elif event_type == \"prefix_added\":\n        print(f\"Added prefix: {kwargs['prefix']} -&gt; {kwargs['uri']}\")\n    elif event_type == \"file_changed\":\n        print(\"File was changed externally\")\n\n# Register the observer\napi.add_observer(on_change)\n\n# Later, remove the observer\napi.remove_observer(on_change)\n</code></pre>"},{"location":"getting-started/#cleanup","title":"Cleanup","text":"<pre><code># Always call stop() when done to release resources\napi.stop()\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>For more detailed information, check out the API Reference section or the Examples in the User Guide.</p>"},{"location":"development/architecture/","title":"Architecture","text":"<p>This document provides an overview of the architecture of the OWL Server, focusing on its Model-Context-Protocol (MCP) integration.</p>"},{"location":"development/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>OWL Server is designed with a layered architecture, with MCP as the primary interface:</p> <pre><code>+--------------------------------------+\n|                                      |\n|       MCP Server &amp; Tools Layer       |\n|                                      |\n+--------------------------------------+\n                  |\n+--------------------------------------+\n|                                      |\n|           SimpleOwlAPI               |\n|                                      |\n+--------------------------------------+\n                  |\n+--------------------------------------+\n|                                      |\n|           py-horned-owl              |\n|                                      |\n+--------------------------------------+\n</code></pre> <ol> <li>py-horned-owl Layer: The foundation that provides OWL ontology operations.</li> <li>SimpleOwlAPI Layer: A simplified API on top of py-horned-owl with file synchronization and observer pattern.</li> <li>MCP Server &amp; Tools Layer: The primary interface exposing ontology operations through the standardized Model-Context-Protocol.</li> </ol>"},{"location":"development/architecture/#mcp-server-architecture","title":"MCP Server Architecture","text":"<p>The MCP server is the core component of OWL Server, enabling AI assistants and applications to interact with OWL ontologies:</p> <pre><code>+-----------------------------------+\n|                                   |\n|      AI Assistant / LLM           |\n|                                   |\n+-----------------+-----------------+\n                  |\n                  | MCP Protocol\n                  |\n+-----------------v-----------------+\n|                                   |\n|      OWL Server (MCP Server)      |\n|                                   |\n+-----------------+-----------------+\n                  |\n                  | File I/O\n                  |\n+-----------------v-----------------+\n|                                   |\n|        OWL Ontology Files         |\n|                                   |\n+-----------------------------------+\n</code></pre> <p>The MCP server:</p> <ol> <li>Exposes standardized tools for ontology manipulation</li> <li>Maintains thread-safety for concurrent operations</li> <li>Handles file synchronization automatically</li> <li>Manages instance caching for performance</li> </ol>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#mcp-server-implementation","title":"MCP Server Implementation","text":"<p>The MCP server is implemented using the <code>FastMCP</code> library, which provides a framework for creating Model-Context-Protocol servers:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\n# Initialize MCP server with a name and instructions\nmcp = FastMCP(\"owl-server\", instructions=\"\"\"\nOWL Server provides tools for managing Web Ontology Language (OWL) ontologies.\nUse these tools to add, remove, and find axioms in OWL files, and to manage prefix mappings.\n\nThe tools operate on OWL files specified by absolute paths.\n\"\"\")\n\n# Define MCP tools using decorators\n@mcp.tool()\nasync def add_axiom(owl_file_path: str, axiom_str: str) -&gt; str:\n    # Implementation...\n</code></pre>"},{"location":"development/architecture/#mcp-tools-and-prompts","title":"MCP Tools and Prompts","text":"<p>The OWL Server exposes the following MCP components:</p>"},{"location":"development/architecture/#mcp-tools","title":"MCP Tools","text":"<p>MCP tools are functions that can be invoked by clients to perform operations:</p> <ul> <li><code>add_axiom</code>: Add an axiom to an ontology file</li> <li><code>remove_axiom</code>: Remove an axiom from an ontology file</li> <li><code>find_axioms</code>: Find axioms in an ontology file</li> <li><code>get_all_axioms</code>: Get all axioms from an ontology file</li> <li><code>add_prefix</code>: Add a prefix mapping to an ontology file</li> <li><code>list_active_owl_files</code>: List all active ontology files</li> </ul>"},{"location":"development/architecture/#mcp-prompts","title":"MCP Prompts","text":"<p>MCP prompts provide reusable templates for LLM interactions:</p> <ul> <li><code>ask_for_axioms_about</code>: Generates a prompt asking for explanations about ontology concepts</li> </ul>"},{"location":"development/architecture/#simpleowlapi","title":"SimpleOwlAPI","text":"<p>The <code>SimpleOwlAPI</code> class serves as the middleware between MCP tools and the underlying OWL operations:</p> <ul> <li>Thread-safe operations on OWL ontologies</li> <li>File synchronization with watchdog</li> <li>Observer pattern for change notifications</li> <li>String-based axiom manipulation</li> </ul>"},{"location":"development/architecture/#key-methods","title":"Key Methods","text":"<ul> <li><code>add_axiom()</code>: Add an axiom to the ontology</li> <li><code>remove_axiom()</code>: Remove an axiom from the ontology</li> <li><code>find_axioms()</code>: Find axioms matching a pattern</li> <li><code>get_all_axiom_strings()</code>: Get all axioms as strings</li> <li><code>add_prefix()</code>: Add a prefix mapping to the ontology</li> <li><code>sync_with_file()</code>: Synchronize in-memory representation with file on disk</li> <li><code>add_observer()</code> / <code>remove_observer()</code>: Manage change observers</li> </ul>"},{"location":"development/architecture/#axiom-parser","title":"Axiom Parser","text":"<p>The <code>axiom_parser</code> module handles the conversion between string representations of OWL axioms and the py-horned-owl objects.</p> <p>Key functions:</p> <ul> <li><code>parse_axiom_string()</code>: Parse a string into py-horned-owl axiom objects</li> <li><code>axiom_to_string()</code>: Convert a py-horned-owl axiom to a string</li> <li><code>serialize_axioms()</code>: Serialize a list of axioms to strings</li> </ul>"},{"location":"development/architecture/#mcp-communication-flow","title":"MCP Communication Flow","text":"<p>The typical communication flow when using OWL Server through MCP:</p> <ol> <li> <p>Client Connection:    <pre><code>AI Assistant/Client -&gt; MCP Protocol -&gt; OWL Server\n</code></pre></p> </li> <li> <p>Tool Invocation:    <pre><code>Client -&gt; MCP Tool Request -&gt; OWL Server -&gt; SimpleOwlAPI -&gt; File System\n</code></pre></p> </li> <li> <p>Response Flow:    <pre><code>File System -&gt; SimpleOwlAPI -&gt; MCP Server -&gt; MCP Protocol -&gt; Client\n</code></pre></p> </li> </ol> <p>Example sequence diagram for adding an axiom:</p> <pre><code>Client            MCP Server           SimpleOwlAPI         File System\n  |                   |                      |                   |\n  |---- invoke ------&gt;|                      |                   |\n  |  add_axiom()      |                      |                   |\n  |                   |---- add_axiom() ----&gt;|                   |\n  |                   |                      |---- write -------&gt;|\n  |                   |                      |&lt;---- confirm -----|\n  |                   |&lt;---- success --------|                   |\n  |&lt;---- result ------|                      |                   |\n</code></pre>"},{"location":"development/architecture/#instance-management","title":"Instance Management","text":"<p>OWL Server implements efficient instance management for MCP tools:</p> <pre><code># Dictionary to cache SimpleOwlAPI instances\n_api_instances = {}\n\ndef _get_api_instance(owl_file_path: str) -&gt; SimpleOwlAPI:\n    \"\"\"Get or create a SimpleOwlAPI instance for the given file path.\"\"\"\n    owl_file_path = os.path.abspath(owl_file_path)\n\n    if owl_file_path not in _api_instances:\n        _api_instances[owl_file_path] = SimpleOwlAPI(owl_file_path)\n\n    return _api_instances[owl_file_path]\n</code></pre> <p>This caching mechanism ensures:</p> <ol> <li>Only one API instance per file path</li> <li>Consistent state across multiple MCP tool invocations</li> <li>Efficient resource usage</li> </ol>"},{"location":"development/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"development/architecture/#observer-pattern","title":"Observer Pattern","text":"<p>The observer pattern is used to notify clients of changes to the ontology:</p> <ol> <li>Clients register callback functions using <code>add_observer()</code></li> <li>When changes occur, registered callbacks are notified with event information</li> <li>Clients can unregister using <code>remove_observer()</code></li> </ol>"},{"location":"development/architecture/#thread-safety","title":"Thread Safety","text":"<p>All operations on the ontology are guarded by a reentrant lock to ensure thread safety:</p> <pre><code>with self.lock:\n    # Perform operations on the ontology\n</code></pre>"},{"location":"development/architecture/#file-monitoring","title":"File Monitoring","text":"<p>File monitoring is implemented using the watchdog library:</p> <ol> <li>An <code>Observer</code> watches the directory containing the ontology file</li> <li>When changes are detected, the <code>sync_with_file()</code> method is called</li> <li>This synchronizes the in-memory representation with the file on disk</li> </ol>"},{"location":"development/architecture/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>File Operations: File operations are minimized to improve performance</li> <li>Locking: The lock is acquired only when necessary to minimize contention</li> <li>Hash Checking: File hashes are used to detect changes, avoiding unnecessary reloads</li> <li>Instance Caching: MCP tools cache API instances to avoid recreating them for each call</li> <li>Asynchronous Operations: MCP tools are implemented as async functions for better performance in concurrent environments</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to OWL Server! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"development/contributing/#development-environment","title":"Development Environment","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or later</li> <li>Git</li> </ul>"},{"location":"development/contributing/#setup","title":"Setup","text":"<ol> <li>Fork the repository on GitHub.</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/owl-mcp.git\ncd owl-mcp\n</code></pre></p> </li> <li> <p>Sync your <code>uv</code>:    <pre><code>uv sync --all-extras\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>Tests are written using pytest. To run the tests:</p> <pre><code>make test\n</code></pre> <p>To run a specific test:</p> <pre><code>uv run pytest tests/test_owl_api.py::test_add_axiom\n</code></pre>"},{"location":"development/contributing/#code-formatting","title":"Code Formatting","text":"<p>We use Black for code formatting and isort for import sorting:</p> <pre><code>uv run black src tests\nuv run isort src tests\n</code></pre>"},{"location":"development/contributing/#type-checking","title":"Type Checking","text":"<p>We use mypy for type checking:</p> <pre><code>uv run mypy src\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>We use mkdocs with the Material theme for documentation. To build and serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then visit http://127.0.0.1:8000/ in your web browser.</p>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a new branch for your feature or bugfix:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and ensure all tests pass:    <pre><code>make test\n</code></pre></p> </li> <li> <p>Update the documentation if necessary.</p> </li> <li> <p>Add your changes to git and commit them:    <pre><code>git add .\ngit commit -m \"Description of your changes\"\n</code></pre></p> </li> <li> <p>Push your branch to GitHub:    <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> <li> <p>Create a pull request against the <code>main</code> branch of the original repository.</p> </li> </ol>"},{"location":"development/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Keep pull requests focused on a single issue or feature.</li> <li>Include tests for new functionality or bug fixes.</li> <li>Update documentation as needed.</li> <li>Ensure all tests pass and code is properly formatted.</li> <li>Provide a clear description of what your pull request changes or fixes.</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and considerate of others when contributing to this project. We aim to foster an inclusive and welcoming community.</p>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing to OWL Server, you agree that your contributions will be licensed under the same license as the project.</p>"},{"location":"user-guide/api-reference/","title":"API Reference","text":"<p>This page documents the main classes and methods of the OWL Server, with a focus on its MCP (Model-Context-Protocol) tools and API.</p>"},{"location":"user-guide/api-reference/#mcp-server","title":"MCP Server","text":"<p>OWL Server primarily functions as an MCP server that exposes tools for interacting with OWL ontologies. These tools can be accessed by any MCP client, including AI assistants like Claude and GPT.</p>"},{"location":"user-guide/api-reference/#running-the-mcp-server","title":"Running the MCP Server","text":"<p>To run the OWL Server as an MCP server:</p> <pre><code>python -m owl_mcp.mcp_tools\n</code></pre> <p>This starts the server using the stdio transport, which is suitable for subprocess-based MCP clients.</p>"},{"location":"user-guide/api-reference/#mcp-client-connection","title":"MCP Client Connection","text":"<p>Use the Python MCP client library to connect to the OWL Server:</p> <pre><code>from mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\n\n# Configure the OWL MCP server\nserver_params = StdioServerParameters(\n    command=\"python\",\n    args=[\"-m\", \"owl_mcp.mcp_tools\"]\n)\n\n# Connect to the server\nasync with stdio_client(server_params) as (read, write):\n    async with ClientSession(read, write) as session:\n        await session.initialize()\n\n        # Now you can invoke MCP tools\n        # ...\n</code></pre>"},{"location":"user-guide/api-reference/#mcp-tools-reference","title":"MCP Tools Reference","text":"<p>The following MCP tools are exposed by the OWL Server for interacting with OWL ontologies.</p>"},{"location":"user-guide/api-reference/#add_axiom","title":"<code>add_axiom</code>","text":"<pre><code>async def add_axiom(owl_file_path: str, axiom_str: str) -&gt; str\n</code></pre> <p>Adds an axiom to the ontology using OWL functional syntax.</p> <p>Parameters:</p> <ul> <li><code>owl_file_path</code> (str): Absolute path to the OWL file</li> <li><code>axiom_str</code> (str): String representation of the axiom in OWL functional syntax, e.g., \"SubClassOf(:Dog :Animal)\"</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Success message or error</li> </ul> <p>Example:</p> <pre><code>result = await session.invoke_tool(\"add_axiom\", {\n    \"owl_file_path\": \"/path/to/ontology.owl\",\n    \"axiom_str\": \"SubClassOf(:Dog :Animal)\"\n})\nprint(result)  # \"Successfully added axiom: SubClassOf(:Dog :Animal)\"\n</code></pre>"},{"location":"user-guide/api-reference/#remove_axiom","title":"<code>remove_axiom</code>","text":"<pre><code>async def remove_axiom(owl_file_path: str, axiom_str: str) -&gt; str\n</code></pre> <p>Removes an axiom from the ontology using OWL functional syntax.</p> <p>Parameters:</p> <ul> <li><code>owl_file_path</code> (str): Absolute path to the OWL file</li> <li><code>axiom_str</code> (str): String representation of the axiom in OWL functional syntax</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Success message or error</li> </ul> <p>Example:</p> <pre><code>result = await session.invoke_tool(\"remove_axiom\", {\n    \"owl_file_path\": \"/path/to/ontology.owl\",\n    \"axiom_str\": \"SubClassOf(:Dog :Animal)\"\n})\nprint(result)  # \"Successfully removed axiom: SubClassOf(:Dog :Animal)\"\n</code></pre>"},{"location":"user-guide/api-reference/#find_axioms","title":"<code>find_axioms</code>","text":"<pre><code>async def find_axioms(owl_file_path: str, pattern: str, limit: int = 100) -&gt; List[str]\n</code></pre> <p>Finds axioms matching a pattern in the ontology.</p> <p>Parameters:</p> <ul> <li><code>owl_file_path</code> (str): Absolute path to the OWL file</li> <li><code>pattern</code> (str): A string pattern to match against axiom strings (simple substring matching)</li> <li><code>limit</code> (int, optional): Maximum number of axioms to return. Defaults to 100.</li> </ul> <p>Returns:</p> <ul> <li><code>List[str]</code>: List of matching axiom strings</li> </ul> <p>Example:</p> <pre><code>axioms = await session.invoke_tool(\"find_axioms\", {\n    \"owl_file_path\": \"/path/to/ontology.owl\",\n    \"pattern\": \"Dog\",\n    \"limit\": 50\n})\nfor axiom in axioms:\n    print(axiom)\n</code></pre>"},{"location":"user-guide/api-reference/#get_all_axioms","title":"<code>get_all_axioms</code>","text":"<pre><code>async def get_all_axioms(owl_file_path: str, limit: int = 100) -&gt; List[str]\n</code></pre> <p>Gets all axioms in the ontology as strings.</p> <p>Parameters:</p> <ul> <li><code>owl_file_path</code> (str): Absolute path to the OWL file</li> <li><code>limit</code> (int, optional): Maximum number of axioms to return. Defaults to 100.</li> </ul> <p>Returns:</p> <ul> <li><code>List[str]</code>: List of all axiom strings</li> </ul> <p>Example:</p> <pre><code>axioms = await session.invoke_tool(\"get_all_axioms\", {\n    \"owl_file_path\": \"/path/to/ontology.owl\",\n    \"limit\": 200\n})\nprint(f\"Ontology contains {len(axioms)} axioms\")\n</code></pre>"},{"location":"user-guide/api-reference/#add_prefix","title":"<code>add_prefix</code>","text":"<pre><code>async def add_prefix(owl_file_path: str, prefix: str, uri: str) -&gt; str\n</code></pre> <p>Adds a prefix mapping to the ontology.</p> <p>Parameters:</p> <ul> <li><code>owl_file_path</code> (str): Absolute path to the OWL file</li> <li><code>prefix</code> (str): The prefix string (e.g., \"ex:\")</li> <li><code>uri</code> (str): The URI the prefix maps to (e.g., \"http://example.org/\")</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Success message or error</li> </ul> <p>Example:</p> <pre><code>result = await session.invoke_tool(\"add_prefix\", {\n    \"owl_file_path\": \"/path/to/ontology.owl\",\n    \"prefix\": \"ex:\",\n    \"uri\": \"http://example.org/\"\n})\nprint(result)  # \"Successfully added prefix mapping: ex: -&gt; http://example.org/\"\n</code></pre>"},{"location":"user-guide/api-reference/#list_active_owl_files","title":"<code>list_active_owl_files</code>","text":"<pre><code>async def list_active_owl_files() -&gt; List[str]\n</code></pre> <p>Lists all OWL files currently being managed by the MCP server.</p> <p>Returns:</p> <ul> <li><code>List[str]</code>: List of file paths for active OWL files</li> </ul> <p>Example:</p> <pre><code>active_files = await session.invoke_tool(\"list_active_owl_files\", {})\nfor file_path in active_files:\n    print(f\"Active OWL file: {file_path}\")\n</code></pre>"},{"location":"user-guide/api-reference/#core-api-simpleowlapi","title":"Core API (SimpleOwlAPI)","text":"<p>The MCP server is built on top of the <code>SimpleOwlAPI</code> class, which can be used directly if you prefer to work with OWL ontologies without the MCP protocol.</p>"},{"location":"user-guide/api-reference/#constructor","title":"Constructor","text":"<pre><code>SimpleOwlAPI(owl_file_path: str, create_if_not_exists: bool = True, serialization: Optional[str] = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>owl_file_path</code> (str): Path to the OWL file</li> <li><code>create_if_not_exists</code> (bool, optional): Whether to create the file if it doesn't exist. Defaults to True.</li> <li><code>serialization</code> (str, optional): Serialization format (e.g., \"ofn\", \"owl\", \"rdfxml\"). If not specified, it will be inferred from the file extension or content.</li> </ul>"},{"location":"user-guide/api-reference/#key-methods","title":"Key Methods","text":""},{"location":"user-guide/api-reference/#add_axiom_1","title":"<code>add_axiom</code>","text":"<pre><code>add_axiom(axiom_str: str) -&gt; bool\n</code></pre> <p>Adds an axiom to the ontology using OWL functional syntax.</p>"},{"location":"user-guide/api-reference/#remove_axiom_1","title":"<code>remove_axiom</code>","text":"<pre><code>remove_axiom(axiom_str: str) -&gt; bool\n</code></pre> <p>Removes an axiom from the ontology.</p>"},{"location":"user-guide/api-reference/#find_axioms_1","title":"<code>find_axioms</code>","text":"<pre><code>find_axioms(pattern: Optional[str], axiom_type: Optional[str] = None) -&gt; List[str]\n</code></pre> <p>Finds axioms matching a pattern in the ontology.</p>"},{"location":"user-guide/api-reference/#get_all_axiom_strings","title":"<code>get_all_axiom_strings</code>","text":"<pre><code>get_all_axiom_strings() -&gt; List[str]\n</code></pre> <p>Gets all axioms in the ontology as strings.</p>"},{"location":"user-guide/api-reference/#add_prefix_1","title":"<code>add_prefix</code>","text":"<pre><code>add_prefix(prefix: str, uri: str) -&gt; bool\n</code></pre> <p>Adds a prefix mapping to the ontology.</p>"},{"location":"user-guide/api-reference/#add_observer-remove_observer","title":"<code>add_observer</code> / <code>remove_observer</code>","text":"<pre><code>add_observer(callback: Callable) -&gt; None\nremove_observer(callback: Callable) -&gt; None\n</code></pre> <p>Adds or removes an observer to be notified of ontology changes.</p>"},{"location":"user-guide/api-reference/#stop","title":"<code>stop</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stops the API and releases resources, particularly the file monitoring thread.</p> <p>For complete details on the <code>SimpleOwlAPI</code> methods, see the source code.</p>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers common usage patterns and examples for the OWL Server library.</p>"},{"location":"user-guide/basic-usage/#core-concepts","title":"Core Concepts","text":"<p>OWL Server is built around a few key concepts:</p> <ol> <li>SimpleOwlAPI: The main interface for working with OWL ontologies</li> <li>Thread Safety: All operations are guarded by locks for concurrent access</li> <li>File Monitoring: Changes to files on disk are detected automatically</li> <li>Observer Pattern: Register callbacks to be notified of changes</li> <li>Functional Syntax: Work with axioms in OWL functional syntax as strings</li> </ol>"},{"location":"user-guide/basic-usage/#creating-and-opening-ontologies","title":"Creating and Opening Ontologies","text":""},{"location":"user-guide/basic-usage/#creating-a-new-ontology","title":"Creating a New Ontology","text":"<pre><code>from owl_mcp.owl_api import SimpleOwlAPI\n\n# Create a new ontology file\napi = SimpleOwlAPI(\"new-ontology.owl\", create_if_not_exists=True)\n\n# Add some standard prefixes\napi.add_prefix(\"owl\", \"http://www.w3.org/2002/07/owl#\")\napi.add_prefix(\"rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\")\napi.add_prefix(\"rdfs\", \"http://www.w3.org/2000/01/rdf-schema#\")\napi.add_prefix(\"xsd\", \"http://www.w3.org/2001/XMLSchema#\")\napi.add_prefix(\"ex\", \"http://example.org/\")\n</code></pre>"},{"location":"user-guide/basic-usage/#opening-an-existing-ontology","title":"Opening an Existing Ontology","text":"<pre><code>from owl_mcp.owl_api import SimpleOwlAPI\n\n# Open an existing ontology file\napi = SimpleOwlAPI(\"existing-ontology.owl\")\n</code></pre>"},{"location":"user-guide/basic-usage/#specifying-serialization-format","title":"Specifying Serialization Format","text":"<pre><code>from owl_mcp.owl_api import SimpleOwlAPI\n\n# Open with a specific serialization format\napi = SimpleOwlAPI(\"ontology.owl\", serialization=\"rdfxml\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-axioms","title":"Working with Axioms","text":""},{"location":"user-guide/basic-usage/#adding-axioms","title":"Adding Axioms","text":"<pre><code># Add class axioms\napi.add_axiom(\"Declaration(Class(ex:Person))\")\napi.add_axiom(\"Declaration(Class(ex:Student))\")\napi.add_axiom(\"SubClassOf(ex:Student ex:Person)\")\n\n# Add individual axioms\napi.add_axiom(\"Declaration(NamedIndividual(ex:John))\")\napi.add_axiom(\"ClassAssertion(ex:Person ex:John)\")\n\n# Add object property axioms\napi.add_axiom(\"Declaration(ObjectProperty(ex:knows))\")\napi.add_axiom(\"ObjectPropertyAssertion(ex:knows ex:John ex:Jane)\")\n</code></pre>"},{"location":"user-guide/basic-usage/#removing-axioms","title":"Removing Axioms","text":"<pre><code># Remove an axiom\napi.remove_axiom(\"ClassAssertion(ex:Person ex:John)\")\n</code></pre>"},{"location":"user-guide/basic-usage/#finding-axioms","title":"Finding Axioms","text":"<pre><code># Get all axioms\nall_axioms = api.get_all_axiom_strings()\nfor axiom in all_axioms:\n    print(axiom)\n\n# Find axioms containing a pattern\nperson_axioms = api.find_axioms(\"ex:Person\")\nfor axiom in person_axioms:\n    print(axiom)\n\n# Find axioms of a specific type\nclass_axioms = api.find_axioms(pattern=None, axiom_type=\"ClassAssertion\")\n\n# Combine pattern and type\nstudent_class_axioms = api.find_axioms(\"ex:Student\", \"SubClassOf\")\n</code></pre>"},{"location":"user-guide/basic-usage/#managing-prefixes","title":"Managing Prefixes","text":"<pre><code># Add a prefix\napi.add_prefix(\"ex\", \"http://example.org/\")\n\n# Add multiple prefixes\nprefixes = {\n    \"foaf\": \"http://xmlns.com/foaf/0.1/\",\n    \"dc\": \"http://purl.org/dc/elements/1.1/\"\n}\nfor prefix, uri in prefixes.items():\n    api.add_prefix(prefix, uri)\n</code></pre>"},{"location":"user-guide/basic-usage/#observing-changes","title":"Observing Changes","text":"<p>The observer pattern allows you to register callbacks that will be notified of changes to the ontology.</p>"},{"location":"user-guide/basic-usage/#event-types","title":"Event Types","text":"<ul> <li><code>axiom_added</code>: Fired when an axiom is added</li> <li><code>axiom_removed</code>: Fired when an axiom is removed</li> <li><code>prefix_added</code>: Fired when a prefix is added</li> <li><code>file_changed</code>: Fired when the file is changed externally</li> </ul>"},{"location":"user-guide/basic-usage/#registering-observers","title":"Registering Observers","text":"<pre><code>def on_change(event_type, **kwargs):\n    print(f\"Event: {event_type}\")\n    if event_type == \"axiom_added\":\n        print(f\"Added axiom: {kwargs['axiom_str']}\")\n    elif event_type == \"axiom_removed\":\n        print(f\"Removed axiom: {kwargs['axiom_str']}\")\n    elif event_type == \"prefix_added\":\n        print(f\"Added prefix: {kwargs['prefix']} -&gt; {kwargs['uri']}\")\n    elif event_type == \"file_changed\":\n        print(\"File was changed externally\")\n\n# Register the observer\napi.add_observer(on_change)\n\n# Make some changes\napi.add_axiom(\"ClassAssertion(ex:Person ex:Alice)\")  # Triggers axiom_added event\n\n# Later, remove the observer\napi.remove_observer(on_change)\n</code></pre>"},{"location":"user-guide/basic-usage/#file-synchronization","title":"File Synchronization","text":"<p>OWL Server automatically monitors the ontology file for changes and synchronizes the in-memory representation with the file on disk. This is useful in collaborative environments where multiple processes might be modifying the same file.</p> <pre><code># Changes made to the file by external processes are automatically detected\n# and the in-memory ontology is synchronized\n\n# To manually trigger synchronization\napi.sync_with_file()\n</code></pre>"},{"location":"user-guide/basic-usage/#resource-management","title":"Resource Management","text":"<p>Always call <code>stop()</code> when done with the API to release resources, particularly the file monitoring threads:</p> <pre><code># Clean up resources\napi.stop()\n</code></pre>"},{"location":"user-guide/basic-usage/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing the main features:</p> <pre><code>from owl_mcp.owl_api import SimpleOwlAPI\n\n# Create or open an ontology\napi = SimpleOwlAPI(\"university.owl\", create_if_not_exists=True)\n\n# Add prefixes\napi.add_prefix(\"owl\", \"http://www.w3.org/2002/07/owl#\")\napi.add_prefix(\"rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\")\napi.add_prefix(\"rdfs\", \"http://www.w3.org/2000/01/rdf-schema#\")\napi.add_prefix(\"xsd\", \"http://www.w3.org/2001/XMLSchema#\")\napi.add_prefix(\"univ\", \"http://example.org/university#\")\n\n# Define a change listener\ndef on_change(event_type, **kwargs):\n    print(f\"Event: {event_type}\")\n    if event_type == \"axiom_added\":\n        print(f\"Added: {kwargs['axiom_str']}\")\n    elif event_type == \"axiom_removed\":\n        print(f\"Removed: {kwargs['axiom_str']}\")\n\n# Register the observer\napi.add_observer(on_change)\n\n# Add class hierarchy\napi.add_axiom(\"Declaration(Class(univ:Person))\")\napi.add_axiom(\"Declaration(Class(univ:Student))\")\napi.add_axiom(\"Declaration(Class(univ:Professor))\")\napi.add_axiom(\"SubClassOf(univ:Student univ:Person)\")\napi.add_axiom(\"SubClassOf(univ:Professor univ:Person)\")\n\n# Add properties\napi.add_axiom(\"Declaration(ObjectProperty(univ:teaches))\")\napi.add_axiom(\"Declaration(ObjectProperty(univ:enrolledIn))\")\napi.add_axiom(\"Declaration(DataProperty(univ:name))\")\napi.add_axiom(\"Declaration(DataProperty(univ:studentId))\")\n\n# Add individuals\napi.add_axiom(\"Declaration(NamedIndividual(univ:John))\")\napi.add_axiom(\"ClassAssertion(univ:Professor univ:John)\")\napi.add_axiom(\"Declaration(NamedIndividual(univ:CS101))\")\napi.add_axiom(\"ObjectPropertyAssertion(univ:teaches univ:John univ:CS101)\")\n\n# Find all professors\nprofessors = api.find_axioms(\"univ:Professor\", \"ClassAssertion\")\nprint(\"\\nProfessors:\")\nfor p in professors:\n    print(f\"- {p}\")\n\n# Find all courses taught by John\njohn_courses = api.find_axioms(\"univ:John\", \"ObjectPropertyAssertion\")\nprint(\"\\nJohn's courses:\")\nfor c in john_courses:\n    print(f\"- {c}\")\n\n# Clean up\napi.stop()\n</code></pre>"},{"location":"user-guide/basic-usage/#next-steps","title":"Next Steps","text":"<p>For more detailed information about the API, see the API Reference section.</p>"},{"location":"user-guide/configuration/","title":"Configuration System","text":"<p>OWL-Server includes a configuration system that allows you to define named ontologies  with consistent settings and metadata. This system provides an easier way to work with frequently used ontologies and ensures consistency across sessions.</p>"},{"location":"user-guide/configuration/#configuration-file","title":"Configuration File","text":"<p>The configuration is stored in YAML format at <code>~/.owl-mcp/config.yaml</code>. This file is automatically created when you first use the OWL-Server.</p> <p>A sample configuration file might look like this:</p> <pre><code>ontologies:\n  pizza:\n    path: /path/to/pizza.owl\n    metadata_axioms:\n      - 'AnnotationAssertion(rdfs:label ont:PizzaOntology \"Pizza Ontology\")'\n      - 'AnnotationAssertion(owl:versionInfo ont:PizzaOntology \"1.0.0\")'\n    readonly: false\n    description: A sample pizza ontology\n    preferred_serialization: ofn\n\n  go:\n    path: /data/ontologies/go.owl\n    metadata_axioms: []\n    readonly: true\n    description: Gene Ontology (read-only reference)\n    preferred_serialization: owl\n\ndefault_serialization: ofn\nenable_auto_discovery: true\nlog_level: INFO\neditor_command: vim\ndefault_namespace: http://example.org/\n</code></pre>"},{"location":"user-guide/configuration/#configuration-fields","title":"Configuration Fields","text":""},{"location":"user-guide/configuration/#global-settings","title":"Global Settings","text":"<ul> <li><code>default_serialization</code>: Default serialization format for OWL files</li> <li><code>enable_auto_discovery</code>: Whether to automatically discover ontologies in common locations</li> <li><code>log_level</code>: Log level for OWL-Server (DEBUG, INFO, WARNING, ERROR)</li> <li><code>editor_command</code>: Command to use when opening ontologies in an external editor</li> <li><code>default_namespace</code>: Default namespace for newly created ontologies</li> </ul>"},{"location":"user-guide/configuration/#ontology-configuration","title":"Ontology Configuration","text":"<p>Each configured ontology has the following fields:</p> <ul> <li><code>path</code>: Absolute path to the OWL file</li> <li><code>metadata_axioms</code>: List of metadata axioms to apply to the ontology</li> <li><code>readonly</code>: Whether the ontology is read-only</li> <li><code>description</code>: Optional description of the ontology</li> <li><code>preferred_serialization</code>: Preferred serialization format for this ontology</li> </ul>"},{"location":"user-guide/configuration/#using-the-configuration-system","title":"Using the Configuration System","text":"<p>You can manage configurations in multiple ways:</p> <ol> <li>Directly editing the YAML file: Edit <code>~/.owl-mcp/config.yaml</code> with a text editor</li> <li>Through MCP tools: Use the configuration tools provided by the MCP server</li> <li>Programmatically: Use the <code>ConfigManager</code> API in the <code>owl_mcp.config</code> module</li> </ol>"},{"location":"user-guide/configuration/#accessing-configuration","title":"Accessing Configuration","text":"<p>There are multiple ways to work with the configuration system:</p>"},{"location":"user-guide/configuration/#mcp-configuration-tools","title":"MCP Configuration Tools","text":"<p>The following MCP tools are available for managing ontology configurations:</p>"},{"location":"user-guide/configuration/#managing-configurations","title":"Managing Configurations","text":"<ul> <li><code>list_configured_ontologies()</code>: Lists all configured ontologies</li> <li><code>configure_ontology(name, path, metadata_axioms=None, readonly=False, description=None, preferred_serialization=None)</code>: Adds or updates an ontology configuration</li> <li><code>remove_ontology_config(name)</code>: Removes an ontology from the configuration</li> <li><code>get_ontology_config(name)</code>: Gets configuration details for a specific ontology</li> <li><code>register_ontology_in_config(owl_file_path, name=None, readonly=None, description=None, preferred_serialization=None)</code>: Registers an existing ontology in the configuration</li> <li><code>load_and_register_ontology(owl_file_path, name=None, readonly=False, create_if_not_exists=True, description=None, preferred_serialization=None, metadata_axioms=None)</code>: Loads an ontology and registers it in the configuration in one step</li> </ul>"},{"location":"user-guide/configuration/#api-methods","title":"API Methods","text":"<p>The <code>SimpleOwlAPI</code> class provides the following methods for working with configurations:</p> <ul> <li><code>register_in_config(name=None, readonly=None, description=None, preferred_serialization=None)</code>: Registers the current ontology in the configuration system</li> </ul>"},{"location":"user-guide/configuration/#working-with-named-ontologies","title":"Working with Named Ontologies","text":"<p>The following tools allow you to work with ontologies by name instead of path:</p> <ul> <li><code>add_axiom_by_name(ontology_name, axiom_str)</code>: Adds an axiom to a named ontology</li> <li><code>remove_axiom_by_name(ontology_name, axiom_str)</code>: Removes an axiom from a named ontology</li> <li><code>find_axioms_by_name(ontology_name, pattern, limit=100)</code>: Finds axioms in a named ontology</li> <li><code>add_prefix_by_name(ontology_name, prefix, uri)</code>: Adds a prefix to a named ontology</li> </ul>"},{"location":"user-guide/configuration/#mcp-resources","title":"MCP Resources","text":"<p>The following MCP resources allow direct access to configuration data:</p> <ul> <li><code>resource://config/ontologies</code>: List of all configured ontologies</li> <li><code>resource://config/ontology/{name}</code>: Details about a specific ontology configuration</li> <li><code>resource://active</code>: List of all active OWL file paths</li> </ul> <p>Example of using resources:</p> <pre><code>from fastmcp import Client\n\nasync with Client(\"owl-server\") as client:\n    # Get all configured ontologies\n    ontologies = await client.read_resource(\"resource://config/ontologies\")\n\n    # Print the names of all configured ontologies\n    print(\"Configured ontologies:\")\n    for ontology in ontologies.value:\n        print(f\"- {ontology['name']}: {ontology['path']}\")\n\n    # Get details about a specific ontology\n    pizza = await client.read_resource(\"resource://config/ontology/pizza\")\n    if pizza.value:\n        print(f\"Pizza ontology at: {pizza.value['path']}\")\n        print(f\"Read-only: {pizza.value['readonly']}\")\n\n    # Get list of active ontologies\n    active = await client.read_resource(\"resource://active\")\n    print(f\"Active ontologies: {len(active.value)}\")\n</code></pre>"},{"location":"user-guide/configuration/#readonly-ontologies","title":"Readonly Ontologies","text":"<p>When an ontology is marked as readonly, the following behavior applies:</p> <ol> <li>Attempts to add, remove, or modify axioms will be rejected</li> <li>Changes to the in-memory representation are allowed, but will not be saved to disk</li> <li>This is useful for reference ontologies that shouldn't be modified</li> </ol>"},{"location":"user-guide/configuration/#metadata-axioms","title":"Metadata Axioms","text":"<p>The metadata_axioms field allows you to define ontology-level metadata that will be  automatically added when the ontology is loaded. This is useful for:</p> <ol> <li>Ensuring consistent metadata across sessions</li> <li>Adding standard annotations to all ontologies</li> <li>Setting version information, labels, and other metadata</li> </ol> <p>Metadata axioms are specified in OWL functional syntax, typically as annotation assertions.</p>"},{"location":"user-guide/configuration/#examples","title":"Examples","text":""},{"location":"user-guide/configuration/#example-1-configuring-and-using-a-named-ontology","title":"Example 1: Configuring and Using a Named Ontology","text":"<p>Here's an example of how to configure and use a named ontology through MCP:</p> <pre><code>from fastmcp import Client\n\nasync with Client(\"owl-server\") as client:\n    # Configure a new ontology\n    await client.call_tool(\"configure_ontology\", {\n        \"name\": \"pizza\",\n        \"path\": \"/path/to/pizza.owl\",\n        \"metadata_axioms\": [\n            'AnnotationAssertion(rdfs:label ont:PizzaOntology \"Pizza Ontology\")',\n            'AnnotationAssertion(owl:versionInfo ont:PizzaOntology \"1.0.0\")'\n        ],\n        \"description\": \"A sample pizza ontology\"\n    })\n\n    # Now use it by name (no need to remember the path)\n    await client.call_tool(\"add_axiom_by_name\", {\n        \"ontology_name\": \"pizza\",\n        \"axiom_str\": \"Declaration(Class(pizza:VegetarianPizza))\"\n    })\n\n    # Find axioms by pattern\n    results = await client.call_tool(\"find_axioms_by_name\", {\n        \"ontology_name\": \"pizza\",\n        \"pattern\": \"Vegetarian\"\n    })\n\n    print(f\"Found {len(results)} axioms about vegetarian pizzas\")\n</code></pre>"},{"location":"user-guide/configuration/#example-2-loading-and-registering-in-one-step","title":"Example 2: Loading and Registering in One Step","text":"<p>Here's an example of using the <code>load_and_register_ontology</code> tool:</p> <pre><code>from fastmcp import Client\n\nasync with Client(\"owl-server\") as client:\n    # Load and register a new ontology in one step\n    result = await client.call_tool(\"load_and_register_ontology\", {\n        \"owl_file_path\": \"/data/ontologies/gene_ontology.owl\",\n        \"name\": \"go\",\n        \"readonly\": True,\n        \"description\": \"Gene Ontology (read-only reference)\",\n        \"metadata_axioms\": [\n            'AnnotationAssertion(rdfs:label ont:GO \"Gene Ontology\")',\n            'AnnotationAssertion(owl:versionInfo ont:GO \"2023-05-14\")'\n        ]\n    })\n\n    print(result)  # \"Loaded and registered ontology 'go' at /data/ontologies/gene_ontology.owl\"\n\n    # Now use it by name\n    axioms = await client.call_tool(\"find_axioms_by_name\", {\n        \"ontology_name\": \"go\",\n        \"pattern\": \"mitochondr\"\n    })\n\n    print(f\"Found {len(axioms)} axioms related to mitochondria\")\n</code></pre>"},{"location":"user-guide/configuration/#example-3-registering-an-open-ontology","title":"Example 3: Registering an Open Ontology","text":"<p>Here's an example of using the API directly to register an ontology that's already loaded:</p> <pre><code>from owl_mcp.owl_api import SimpleOwlAPI\nfrom owl_mcp.config import get_config_manager\n\n# First load an ontology\napi = SimpleOwlAPI(\"/path/to/ontology.owl\")\n\n# Add some axioms\napi.add_axiom(\"Declaration(Class(ex:MyClass))\")\napi.add_axiom(\"SubClassOf(ex:MyClass owl:Thing)\")\n\n# Now register it in the configuration\nname = api.register_in_config(\n    name=\"my-ontology\",\n    description=\"My custom ontology\",\n    readonly=False\n)\n\nprint(f\"Registered as '{name}' in configuration\")\n\n# Verify it's in the configuration\nconfig_manager = get_config_manager()\nprint(config_manager.get_ontology(\"my-ontology\"))\n</code></pre> <p>Using named ontologies makes it much easier to work with frequently used ontologies, as you no longer need to remember or type long file paths.</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>This page covers how to install OWL Server and set it up for use as an MCP server.</p>"},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or later</li> <li>py-horned-owl for OWL ontology processing</li> <li>watchdog for file monitoring</li> <li>mcp for the Model-Context-Protocol implementation</li> </ul>"},{"location":"user-guide/installation/#standard-installation","title":"Standard Installation","text":"<p>The simplest way to install OWL Server is via pip:</p> <pre><code>pip install owl-server\n</code></pre> <p>This will install all required dependencies, including the MCP Python SDK.</p>"},{"location":"user-guide/installation/#mcp-specific-installation","title":"MCP-Specific Installation","text":"<p>For optimal MCP server usage, make sure you have the latest MCP SDK installed:</p> <pre><code>pip install \"mcp&gt;=0.1.0\"\n</code></pre>"},{"location":"user-guide/installation/#development-installation","title":"Development Installation","text":"<p>For development purposes, you can install the package with development dependencies:</p> <pre><code># Clone the repository\ngit clone https://github.com/your-username/owl-server.git\ncd owl-server\n\n# Install the package with development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"user-guide/installation/#using-uv-package-manager","title":"Using UV package manager","text":"<p>If you're using UV, which is recommended for faster dependency resolution:</p> <pre><code># Install UV if you don't have it\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install OWL Server with MCP dependencies\nuv pip install owl-server \"mcp&gt;=0.1.0\"\n</code></pre> <p>Or for development:</p> <pre><code>uv pip install -e \".[dev]\"\n</code></pre>"},{"location":"user-guide/installation/#verifying-mcp-server-installation","title":"Verifying MCP Server Installation","text":"<p>After installation, you can verify the MCP server functionality with:</p> <pre><code>import asyncio\nfrom mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\n\nasync def verify_mcp_server():\n    # Configure the OWL MCP server\n    server_params = StdioServerParameters(\n        command=\"python\",\n        args=[\"-m\", \"owl_mcp.mcp_tools\"]\n    )\n\n    # Connect to the server\n    print(\"Connecting to OWL MCP server...\")\n    try:\n        async with stdio_client(server_params) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n\n                # List available tools to verify connection\n                tools = await session.list_tools()\n                print(f\"MCP server connection successful!\")\n                print(f\"Available tools: {[tool.name for tool in tools]}\")\n\n    except Exception as e:\n        print(f\"MCP server connection failed: {str(e)}\")\n\n# Run the verification\nasyncio.run(verify_mcp_server())\n</code></pre>"},{"location":"user-guide/installation/#running-the-mcp-server","title":"Running the MCP Server","text":"<p>Start the OWL MCP server from the command line:</p> <pre><code>python -m owl_mcp.mcp_tools\n</code></pre> <p>This runs the server using the stdio transport, suitable for subprocess-based MCP clients. The server will remain running until it receives a termination signal or the process is interrupted.</p>"},{"location":"user-guide/installation/#mcp-client-dependencies","title":"MCP Client Dependencies","text":"<p>If you're developing a client application that will connect to the OWL MCP server, make sure to install the MCP client libraries:</p> <pre><code>pip install \"mcp&gt;=0.1.0\"\n</code></pre> <p>For integration with AI frameworks like LangChain or LlamaIndex:</p> <pre><code>pip install \"mcp[langchain]&gt;=0.1.0\"  # For LangChain integration\npip install \"mcp[llamaindex]&gt;=0.1.0\"  # For LlamaIndex integration\n</code></pre>"},{"location":"user-guide/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>OWL Server has optional dependencies for specific features:</p> <ul> <li> <p>Development: For development tasks (testing, linting, documentation), install with the <code>dev</code> extra:   <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Performance: For improved performance with larger ontologies:   <pre><code>pip install \"owl-server[performance]\"\n</code></pre></p> </li> </ul>"},{"location":"user-guide/installation/#docker-installation","title":"Docker Installation","text":"<p>You can also run OWL Server as an MCP server using Docker:</p> <pre><code># Build the Docker image\ndocker build -t owl-mcp-server .\n\n# Run the MCP server\ndocker run -p 8000:8000 -v /path/to/ontologies:/ontologies owl-mcp-server\n</code></pre>"},{"location":"user-guide/installation/#next-steps","title":"Next Steps","text":"<ul> <li>See the MCP Client Usage guide for examples of connecting to the OWL MCP server</li> <li>Check the API Reference for details on available MCP tools</li> <li>Review Basic Usage for core concepts and examples</li> </ul>"},{"location":"user-guide/mcp-client-usage/","title":"MCP Client Usage","text":"<p>This guide provides examples of how to use OWL Server through the Model Context Protocol (MCP) from different client environments.</p>"},{"location":"user-guide/mcp-client-usage/#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open standard for connecting AI assistants to external tools and data sources. It provides a standardized way for applications to expose functionality to large language models (LLMs) and other AI systems.</p> <p>OWL Server implements MCP, allowing you to:</p> <ul> <li>Connect AI assistants directly to OWL ontologies</li> <li>Perform ontology operations through a standardized interface</li> <li>Integrate with any MCP-compatible client</li> </ul>"},{"location":"user-guide/mcp-client-usage/#basic-mcp-client-connection","title":"Basic MCP Client Connection","text":"<p>The following example demonstrates how to connect to the OWL Server using the Python MCP client library:</p> <pre><code>import asyncio\nfrom mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\n\nasync def connect_to_owl_server():\n    # Configure the OWL MCP server\n    server_params = StdioServerParameters(\n        command=\"python\",\n        args=[\"-m\", \"owl_mcp.mcp_tools\"]\n    )\n\n    # Connect to the server\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Now you can invoke MCP tools\n            # ...\n\n    print(\"Connection closed\")\n\n# Run the async function\nasyncio.run(connect_to_owl_server())\n</code></pre>"},{"location":"user-guide/mcp-client-usage/#complete-working-example","title":"Complete Working Example","text":"<p>Here's a complete example that demonstrates creating a new ontology, adding prefixes and axioms, and querying the ontology:</p> <pre><code>import asyncio\nimport os\nfrom mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\n\nasync def owl_example():\n    # Create a temporary ontology file\n    temp_owl_file = os.path.abspath(\"example.owl\")\n\n    # Configure the OWL MCP server\n    server_params = StdioServerParameters(\n        command=\"python\",\n        args=[\"-m\", \"owl_mcp.mcp_tools\"]\n    )\n\n    # Connect to the server\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Add standard prefixes\n            await session.invoke_tool(\"add_prefix\", {\n                \"owl_file_path\": temp_owl_file,\n                \"prefix\": \"owl:\",\n                \"uri\": \"http://www.w3.org/2002/07/owl#\"\n            })\n\n            await session.invoke_tool(\"add_prefix\", {\n                \"owl_file_path\": temp_owl_file,\n                \"prefix\": \"rdf:\",\n                \"uri\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n            })\n\n            await session.invoke_tool(\"add_prefix\", {\n                \"owl_file_path\": temp_owl_file,\n                \"prefix\": \"ex:\",\n                \"uri\": \"http://example.org/\"\n            })\n\n            # Add classes and individuals\n            await session.invoke_tool(\"add_axiom\", {\n                \"owl_file_path\": temp_owl_file,\n                \"axiom_str\": \"Declaration(Class(ex:Animal))\"\n            })\n\n            await session.invoke_tool(\"add_axiom\", {\n                \"owl_file_path\": temp_owl_file,\n                \"axiom_str\": \"Declaration(Class(ex:Dog))\"\n            })\n\n            await session.invoke_tool(\"add_axiom\", {\n                \"owl_file_path\": temp_owl_file,\n                \"axiom_str\": \"SubClassOf(ex:Dog ex:Animal)\"\n            })\n\n            await session.invoke_tool(\"add_axiom\", {\n                \"owl_file_path\": temp_owl_file,\n                \"axiom_str\": \"Declaration(NamedIndividual(ex:Fido))\"\n            })\n\n            await session.invoke_tool(\"add_axiom\", {\n                \"owl_file_path\": temp_owl_file,\n                \"axiom_str\": \"ClassAssertion(ex:Dog ex:Fido)\"\n            })\n\n            # Query the ontology\n            all_axioms = await session.invoke_tool(\"get_all_axioms\", {\n                \"owl_file_path\": temp_owl_file\n            })\n\n            print(\"All axioms in the ontology:\")\n            for axiom in all_axioms:\n                print(f\"  {axiom}\")\n\n            # Find specific axioms\n            dog_axioms = await session.invoke_tool(\"find_axioms\", {\n                \"owl_file_path\": temp_owl_file,\n                \"pattern\": \"Dog\"\n            })\n\n            print(\"\\nAxioms related to 'Dog':\")\n            for axiom in dog_axioms:\n                print(f\"  {axiom}\")\n\n            # Get active OWL files\n            active_files = await session.invoke_tool(\"list_active_owl_files\", {})\n            print(f\"\\nActive OWL files: {active_files}\")\n\n# Run the async function\nasyncio.run(owl_example())\n</code></pre>"},{"location":"user-guide/mcp-client-usage/#using-owl-server-with-ai-assistants","title":"Using OWL Server with AI Assistants","text":"<p>OWL Server can be used with AI assistants that support MCP integration. Here's an example of integrating with an LLM framework:</p> <pre><code>import asyncio\nfrom mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\nfrom langchain.llms import BaseLLM  # Example LLM framework\nfrom langchain.agents import initialize_agent, Tool\nfrom langchain.agents import AgentType\n\nasync def owl_with_llm():\n    # Configure the OWL MCP server\n    server_params = StdioServerParameters(\n        command=\"python\",\n        args=[\"-m\", \"owl_mcp.mcp_tools\"]\n    )\n\n    # Connect to the server\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Create MCP tool wrappers for the LLM\n            owl_tools = [\n                Tool(\n                    name=\"AddAxiom\",\n                    func=lambda args: asyncio.run(session.invoke_tool(\"add_axiom\", {\n                        \"owl_file_path\": args[\"file_path\"],\n                        \"axiom_str\": args[\"axiom\"]\n                    })),\n                    description=\"Add an axiom to an OWL ontology. Args: file_path, axiom\"\n                ),\n                Tool(\n                    name=\"FindAxioms\",\n                    func=lambda args: asyncio.run(session.invoke_tool(\"find_axioms\", {\n                        \"owl_file_path\": args[\"file_path\"],\n                        \"pattern\": args[\"pattern\"]\n                    })),\n                    description=\"Find axioms in an OWL ontology. Args: file_path, pattern\"\n                )\n            ]\n\n            # Initialize LLM and agent (placeholder - use your actual LLM)\n            llm = BaseLLM()  # Replace with your actual LLM\n            agent = initialize_agent(\n                owl_tools, \n                llm, \n                agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n                verbose=True\n            )\n\n            # Example agent query\n            result = agent.run(\n                \"Add the axiom 'SubClassOf(ex:Cat ex:Animal)' to my ontology at /path/to/ontology.owl\"\n            )\n            print(result)\n\n# This example requires actual LLM integration to run\n# asyncio.run(owl_with_llm())\n</code></pre>"},{"location":"user-guide/mcp-client-usage/#using-owl-server-with-claude-or-gpt","title":"Using OWL Server with Claude or GPT","text":"<p>AI assistants like Claude or GPT that have MCP capabilities can use OWL Server directly:</p> <pre><code># Example prompt for Claude with MCP capabilities:\n\nUse the OWL Server MCP tools to create a small ontology about pets.\nStart by creating a file called \"pets.owl\" and add the following:\n1. Standard OWL prefixes\n2. Animal, Dog, Cat, and Bird classes\n3. Make Dog, Cat, and Bird subclasses of Animal\n4. Add some individual pets (e.g., \"Fido\" as a Dog)\n5. Show me all the axioms in the ontology\n\n# Claude would then use its MCP tools to execute these operations on the OWL Server\n</code></pre>"},{"location":"user-guide/mcp-client-usage/#error-handling","title":"Error Handling","text":"<p>When working with the MCP client, it's important to handle errors properly:</p> <pre><code>import asyncio\nfrom mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\nfrom mcp.errors import MCPToolError\n\nasync def error_handling_example():\n    server_params = StdioServerParameters(\n        command=\"python\",\n        args=[\"-m\", \"owl_mcp.mcp_tools\"]\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            try:\n                # Try to perform an operation on a non-existent file\n                result = await session.invoke_tool(\"find_axioms\", {\n                    \"owl_file_path\": \"/nonexistent/file.owl\",\n                    \"pattern\": \"Dog\"\n                })\n            except MCPToolError as e:\n                print(f\"MCP Tool Error: {e}\")\n\n            try:\n                # Try to add an invalid axiom\n                result = await session.invoke_tool(\"add_axiom\", {\n                    \"owl_file_path\": \"example.owl\",\n                    \"axiom_str\": \"Invalid Axiom Syntax\"\n                })\n            except MCPToolError as e:\n                print(f\"MCP Tool Error: {e}\")\n\n# Run the async function\nasyncio.run(error_handling_example())\n</code></pre>"},{"location":"user-guide/mcp-client-usage/#running-multiple-operations-efficiently","title":"Running Multiple Operations Efficiently","text":"<p>To optimize performance, you can run multiple operations concurrently using <code>asyncio.gather</code>:</p> <pre><code>import asyncio\nfrom mcp import StdioServerParameters, ClientSession\nfrom mcp.client.stdio import stdio_client\n\nasync def concurrent_operations():\n    server_params = StdioServerParameters(\n        command=\"python\",\n        args=[\"-m\", \"owl_mcp.mcp_tools\"]\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Create a file path\n            ontology_path = \"animals.owl\"\n\n            # Run multiple operations concurrently\n            results = await asyncio.gather(\n                session.invoke_tool(\"add_axiom\", {\n                    \"owl_file_path\": ontology_path,\n                    \"axiom_str\": \"Declaration(Class(ex:Animal))\"\n                }),\n                session.invoke_tool(\"add_axiom\", {\n                    \"owl_file_path\": ontology_path,\n                    \"axiom_str\": \"Declaration(Class(ex:Dog))\"\n                }),\n                session.invoke_tool(\"add_axiom\", {\n                    \"owl_file_path\": ontology_path,\n                    \"axiom_str\": \"SubClassOf(ex:Dog ex:Animal))\"\n                })\n            )\n\n            for i, result in enumerate(results):\n                print(f\"Operation {i+1} result: {result}\")\n\n            # Get all axioms to verify\n            axioms = await session.invoke_tool(\"get_all_axioms\", {\n                \"owl_file_path\": ontology_path\n            })\n\n            print(\"\\nAll axioms:\")\n            for axiom in axioms:\n                print(f\"  {axiom}\")\n\n# Run the async function\nasyncio.run(concurrent_operations())\n</code></pre>"},{"location":"user-guide/mcp-client-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Check the API Reference for a complete list of available MCP tools</li> <li>See the Architecture page to learn more about how OWL Server works</li> <li>Explore the Contributing Guide if you want to help improve OWL Server</li> </ul>"}]}